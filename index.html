<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>JJK: Extension de Territoire</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: "Courier New", sans-serif;
        position: fixed;
        width: 100%;
        height: 100%;
        touch-action: none; /* Emp√™che le zoom sur mobile */
      }

      #ui {
        position: absolute;
        top: 5%;
        width: 100%;
        text-align: center;
        color: #fff;
        pointer-events: none;
        z-index: 10;
        padding: 0 10px;
      }

      h1 {
        font-size: clamp(1.5rem, 8vw, 3rem);
        margin: 0;
        letter-spacing: 5px;
        font-weight: 900;
        text-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        background: linear-gradient(to bottom, #fff, #888);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      #technique-name {
        font-size: clamp(0.8rem, 4vw, 1.2rem);
        color: #00ffff;
        margin-top: 10px;
        font-weight: bold;
        letter-spacing: 2px;
        text-transform: uppercase;
        text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        padding: 0 10px;
        line-height: 1.4;
      }

      #technique-description {
        font-size: clamp(0.7rem, 3vw, 0.9rem);
        color: #aaa;
        margin-top: 5px;
        letter-spacing: 1px;
        padding: 0 10px;
      }

      #video-container {
        position: absolute;
        bottom: 2%;
        left: 50%;
        transform: translateX(-50%) scaleX(-1);
        width: min(90vw, 400px);
        height: min(35vh, 300px);
        border: 2px solid rgba(255, 255, 255, 0.2);
        z-index: 20;
        background-color: #000;
        border-radius: 20px;
        overflow: hidden;
        box-shadow: 0 0 30px rgba(0, 0, 0, 0.9);
      }

      video,
      #output_canvas {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      video {
        opacity: 0.8;
        transform: scaleX(-1); /* Correction du mirror */
      }

      #output_canvas {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
      }

      #grain {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 5;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E");
      }

      #instructions {
        position: absolute;
        bottom: 5%;
        right: 2%;
        color: rgba(255, 255, 255, 0.3);
        font-size: clamp(0.5rem, 2.5vw, 0.7rem);
        z-index: 30;
        text-align: right;
        background: rgba(0, 0, 0, 0.7);
        padding: 8px;
        border-radius: 8px;
        pointer-events: none;
        max-width: 45%;
        backdrop-filter: blur(5px);
      }

      #error-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        background: rgba(0, 0, 0, 0.9);
        padding: 20px;
        border-radius: 15px;
        text-align: center;
        z-index: 100;
        display: none;
        border: 2px solid #ff0000;
        max-width: 80%;
        font-size: clamp(0.8rem, 4vw, 1rem);
      }

      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: cyan;
        font-size: clamp(1rem, 5vw, 1.5rem);
        text-shadow: 0 0 10px cyan;
        z-index: 50;
        text-align: center;
      }

      .permission-button {
        position: absolute;
        bottom: 50%;
        left: 50%;
        transform: translate(-50%, 50%);
        background: rgba(0, 255, 255, 0.2);
        color: cyan;
        border: 2px solid cyan;
        padding: 15px 30px;
        border-radius: 50px;
        font-size: 1.2rem;
        font-weight: bold;
        z-index: 200;
        cursor: pointer;
        backdrop-filter: blur(10px);
        display: none;
        white-space: nowrap;
      }

      @media (orientation: landscape) {
        #video-container {
          width: min(70vw, 450px);
          height: min(45vh, 350px);
        }
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <div id="grain"></div>
    <div id="loading">Initialisation...</div>
    <div id="error-message"></div>
    <button class="permission-button" id="request-permission">
      Activer la cam√©ra üì∑
    </button>

    <div id="ui">
      <h1>Âë™Ë°ìÂªªÊà¶</h1>
      <div id="technique-name">NEUTRE</div>
      <div id="technique-description"></div>
    </div>

    <div id="video-container">
      <video class="input_video" playsinline></video>
      <canvas id="output_canvas"></canvas>
    </div>

    <div id="instructions">
      <div>üñï Index = Rouge</div>
      <div>‚úåÔ∏è 2 doigts = Vide</div>
      <div>ü§è Pincement = Violet</div>
      <div>‚úåÔ∏è Crois√©s = Sanctuaire</div>
    </div>

    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
      crossorigin="anonymous"
    ></script>

    <script type="module">
      // --- D√âTECTION MOBILE ---
      const isMobile =
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent,
        ) || window.innerWidth <= 800;
      const isIOS =
        /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

      console.log("Mobile d√©tect√©:", isMobile, "iOS:", isIOS);

      // Ajustement du nombre de particules pour mobile
      const PARTICLE_COUNT = isMobile ? 8000 : 20000;

      // √âl√©ments UI
      const loadingEl = document.getElementById("loading");
      const errorEl = document.getElementById("error-message");
      const permissionBtn = document.getElementById("request-permission");

      // --- IMPORT THREE (version all√©g√©e) ---
      import * as THREE from "three";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

      // --- SCENE OPTIMIS√âE MOBILE ---
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        isMobile ? 60 : 75, // FOV r√©duit sur mobile
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
      );
      camera.position.z = isMobile ? 65 : 55; // Cam√©ra plus √©loign√©e sur mobile

      const renderer = new THREE.WebGLRenderer({
        antialias: !isMobile, // Pas d'antialiasing sur mobile (performance)
        alpha: true,
        powerPreference: "high-performance",
      });

      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(
        Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2),
      ); // R√©duction pixel ratio sur mobile
      document.body.appendChild(renderer.domElement);

      // Post-processing optionnel sur mobile
      let composer;
      if (!isMobile) {
        composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.5,
          0.4,
          0.85,
        );
        composer.addPass(bloomPass);
      }

      // --- SYST√àME DE PARTICULES OPTIMIS√â ---
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(PARTICLE_COUNT * 3);
      const colors = new Float32Array(PARTICLE_COUNT * 3);
      const sizes = new Float32Array(PARTICLE_COUNT);

      const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
      const targetColors = new Float32Array(PARTICLE_COUNT * 3);
      const targetSizes = new Float32Array(PARTICLE_COUNT);

      geometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3),
      );
      geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute("size", new THREE.BufferAttribute(sizes, 1));

      const particles = new THREE.Points(
        geometry,
        new THREE.PointsMaterial({
          size: isMobile ? 0.5 : 0.3, // Particules plus grosses sur mobile (moins nombreuses)
          vertexColors: true,
          blending: THREE.AdditiveBlending,
          transparent: true,
          depthWrite: false,
        }),
      );
      scene.add(particles);

      // --- FONCTIONS TECHNIQUES (adapt√©es au nouveau COUNT) ---
      function getRed(i) {
        if (i < PARTICLE_COUNT * 0.1) {
          const r = Math.random() * 9;
          const theta = Math.random() * 6.28;
          const phi = Math.acos(2 * Math.random() - 1);
          return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi),
            r: 3,
            g: 0.1,
            b: 0.1,
            s: isMobile ? 1.5 : 2.5,
          };
        } else {
          const armCount = 3;
          const t = i / PARTICLE_COUNT;
          const angle = t * 15 + (i % armCount) * ((Math.PI * 2) / armCount);
          const radius = 2 + t * 40;
          return {
            x: radius * Math.cos(angle),
            y: radius * Math.sin(angle),
            z: (Math.random() - 0.5) * (10 * t),
            r: 0.8,
            g: 0,
            b: 0,
            s: isMobile ? 0.8 : 1.0,
          };
        }
      }

      function getVoid(i) {
        if (i < PARTICLE_COUNT * 0.15) {
          const angle = Math.random() * Math.PI * 2;
          return {
            x: 26 * Math.cos(angle),
            y: 26 * Math.sin(angle),
            z: (Math.random() - 0.5) * 1,
            r: 1,
            g: 1,
            b: 1,
            s: isMobile ? 1.5 : 2.5,
          };
        } else {
          const radius = 30 + Math.random() * 90;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          return {
            x: radius * Math.sin(phi) * Math.cos(theta),
            y: radius * Math.sin(phi) * Math.sin(theta),
            z: radius * Math.cos(phi),
            r: 0.1,
            g: 0.6,
            b: 1.0,
            s: isMobile ? 0.5 : 0.7,
          };
        }
      }

      function getPurple(i) {
        if (Math.random() > 0.8) {
          return {
            x: (Math.random() - 0.5) * 100,
            y: (Math.random() - 0.5) * 100,
            z: (Math.random() - 0.5) * 100,
            r: 0.5,
            g: 0.5,
            b: 0.7,
            s: isMobile ? 0.6 : 0.8,
          };
        }
        const r = 20;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        return {
          x: r * Math.sin(phi) * Math.cos(theta),
          y: r * Math.sin(phi) * Math.sin(theta),
          z: r * Math.cos(phi),
          r: 0.6,
          g: 0.5,
          b: 1.0,
          s: isMobile ? 1.5 : 2.5,
        };
      }

      function getShrine(i) {
        const total = PARTICLE_COUNT;

        if (i < total * 0.3) {
          const angle = Math.random() * Math.PI * 2;
          const radius = 15 + Math.random() * 15;
          return {
            x: radius * Math.cos(angle),
            y: -8 + Math.random() * 2,
            z: radius * Math.sin(angle) * 0.7,
            r: 0.4,
            g: 0.05,
            b: 0.05,
            s: isMobile ? 0.7 : 0.9,
          };
        } else if (i < total * 0.6) {
          const height = Math.random() * 25;
          const radius = 6 * (1 - height / 30);
          const angle = Math.random() * Math.PI * 2;
          return {
            x: radius * Math.cos(angle),
            y: height - 5,
            z: radius * Math.sin(angle) * 0.8,
            r: 0.5 + height / 50,
            g: 0.1,
            b: 0.1,
            s: isMobile ? 0.8 : 1.0,
          };
        } else {
          const radius = 25 + Math.random() * 15;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          return {
            x: radius * Math.sin(phi) * Math.cos(theta),
            y: radius * Math.sin(phi) * Math.sin(theta) * 0.5,
            z: radius * Math.cos(phi) * 0.7,
            r: 0.9,
            g: 0.2,
            b: 0.2,
            s: isMobile ? 0.4 : 0.5,
          };
        }
      }

      // --- GESTION CAM√âRA MOBILE ---
      let currentTech = "neutral";
      let shakeIntensity = 0;
      const videoElement = document.querySelector(".input_video");
      const canvasElement = document.getElementById("output_canvas");
      const canvasCtx = canvasElement.getContext("2d");
      let glowColor = "#00ffff";
      let cameraUtils = null;

      // Configuration MediaPipe optimis√©e mobile
      const hands = new Hands({
        locateFile: (file) =>
          `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
      });
      hands.setOptions({
        maxNumHands: 1, // Une seule main sur mobile (performance)
        modelComplexity: isMobile ? 0 : 1, // Mod√®le l√©ger sur mobile
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });

      hands.onResults((results) => {
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        let detected = "neutral";

        if (
          results.multiHandLandmarks &&
          results.multiHandLandmarks.length > 0
        ) {
          results.multiHandLandmarks.forEach((lm) => {
            // Dessin simplifi√© sur mobile
            if (!isMobile) {
              drawConnectors(canvasCtx, lm, HAND_CONNECTIONS, {
                color: glowColor,
                lineWidth: 3,
              });
            }
            drawLandmarks(canvasCtx, lm, {
              color: "#fff",
              lineWidth: 1,
              radius: isMobile ? 1 : 2,
            });

            const isUp = (tip, pip) => lm[tip].y < lm[pip].y;
            const pinch = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);

            // D√©tection croisement (Sanctuaire)
            const isCrossed =
              Math.abs(lm[8].x - lm[12].x) < 0.03 &&
              lm[8].y < lm[6].y &&
              lm[12].y < lm[10].y;

            if (isCrossed) {
              detected = "shrine";
            } else if (pinch < 0.05) {
              // Seuil ajust√©
              detected = "purple";
            } else if (isUp(8, 6) && isUp(12, 10) && !isUp(16, 14)) {
              detected = "void";
            } else if (isUp(8, 6) && !isUp(12, 10)) {
              detected = "red";
            }
          });
        }
        updateState(detected);
      });

      function updateState(tech) {
        if (currentTech === tech) return;
        currentTech = tech;
        const nameEl = document.getElementById("technique-name");
        const descEl = document.getElementById("technique-description");
        shakeIntensity = tech !== "neutral" && !isMobile ? 0.4 : 0; // Pas de shake sur mobile

        // Mise √† jour UI
        const techInfo = {
          shrine: {
            name: "SANCTUAIRE INNOMMABLE",
            desc: "Sukuna - D√©coupage maudit",
            color: "#8B0000",
            bloom: 2.0,
          },
          purple: {
            name: "VIOLET CREUX",
            desc: "Gojo - Annihilation",
            color: "#bb00ff",
            bloom: 3.0,
          },
          void: {
            name: "VIDE INFINI",
            desc: "Gojo - Infini",
            color: "#00ffff",
            bloom: 1.5,
          },
          red: {
            name: "ROUGE",
            desc: "Gojo - Repoussement",
            color: "#ff3333",
            bloom: 2.0,
          },
          neutral: { name: "NEUTRE", desc: "", color: "#00ffff", bloom: 1.0 },
        };

        const info = techInfo[tech] || techInfo.neutral;
        glowColor = info.color;
        nameEl.innerText = info.name;
        descEl.innerText = info.desc;

        if (!isMobile && composer) {
          composer.passes[1].strength = info.bloom;
        }

        // Mise √† jour des positions cibles
        for (let i = 0; i < PARTICLE_COUNT; i++) {
          let p;
          if (tech === "neutral") {
            if (i < PARTICLE_COUNT * 0.05) {
              const r = 15 + Math.random() * 20;
              const t = Math.random() * 6.28;
              const ph = Math.random() * 3.14;
              p = {
                x: r * Math.sin(ph) * Math.cos(t),
                y: r * Math.sin(ph) * Math.sin(t),
                z: r * Math.cos(ph),
                r: 0.1,
                g: 0.1,
                b: 0.2,
                s: 0.3,
              };
            } else p = { x: 0, y: 0, z: 0, r: 0, g: 0, b: 0, s: 0 };
          } else if (tech === "red") p = getRed(i);
          else if (tech === "void") p = getVoid(i);
          else if (tech === "purple") p = getPurple(i);
          else if (tech === "shrine") p = getShrine(i);

          targetPositions[i * 3] = p.x;
          targetPositions[i * 3 + 1] = p.y;
          targetPositions[i * 3 + 2] = p.z;
          targetColors[i * 3] = p.r;
          targetColors[i * 3 + 1] = p.g;
          targetColors[i * 3 + 2] = p.b;
          targetSizes[i] = p.s;
        }
      }

      // --- INITIALISATION CAM√âRA AVEC GESTION ERREURS ---
      async function initCamera() {
        loadingEl.style.display = "block";
        errorEl.style.display = "none";
        permissionBtn.style.display = "none";

        try {
          // V√©rification support navigateur
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error(
              "Votre navigateur ne supporte pas l'acc√®s √† la cam√©ra",
            );
          }

          // Demande permission explicite pour iOS
          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: "user",
              width: { ideal: isMobile ? 640 : 1280 },
              height: { ideal: isMobile ? 480 : 720 },
            },
          });

          videoElement.srcObject = stream;

          // Attendre que la vid√©o soit pr√™te
          await new Promise((resolve) => {
            videoElement.onloadedmetadata = () => {
              videoElement.play();
              resolve();
            };
          });

          // Initialiser MediaPipe Camera
          cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
              canvasElement.width = videoElement.videoWidth;
              canvasElement.height = videoElement.videoHeight;
              await hands.send({ image: videoElement });
            },
            width: videoElement.videoWidth,
            height: videoElement.videoHeight,
          });

          cameraUtils.start();
          loadingEl.style.display = "none";
        } catch (err) {
          console.error("Erreur cam√©ra:", err);
          loadingEl.style.display = "none";

          if (
            err.name === "NotAllowedError" ||
            err.name === "PermissionDeniedError"
          ) {
            errorEl.innerHTML =
              "üì∑ Permission cam√©ra requise<br>Cliquez ci-dessous pour autoriser";
            errorEl.style.display = "block";
            permissionBtn.style.display = "block";
          } else if (err.name === "NotFoundError") {
            errorEl.innerHTML = "‚ùå Aucune cam√©ra trouv√©e";
            errorEl.style.display = "block";
          } else {
            errorEl.innerHTML = "‚ùå Erreur: " + err.message;
            errorEl.style.display = "block";
          }
        }
      }

      // Bouton permission
      permissionBtn.addEventListener("click", () => {
        initCamera();
      });

      // D√©marrer automatiquement (sauf iOS qui demande interaction)
      if (isIOS) {
        loadingEl.style.display = "none";
        errorEl.innerHTML = "üì± Appuyez pour activer la cam√©ra";
        errorEl.style.display = "block";
        permissionBtn.style.display = "block";
      } else {
        initCamera();
      }

      // --- ANIMATION OPTIMIS√âE ---
      let lastFrame = 0;
      const fps = isMobile ? 30 : 60; // Limite FPS sur mobile
      const frameInterval = 1000 / fps;

      function animate(currentTime) {
        requestAnimationFrame(animate);

        // Limitation FPS sur mobile
        if (isMobile && currentTime - lastFrame < frameInterval) return;
        lastFrame = currentTime;

        // Interpolation
        const pos = particles.geometry.attributes.position.array;
        const col = particles.geometry.attributes.color.array;
        const siz = particles.geometry.attributes.size.array;

        for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
          pos[i] += (targetPositions[i] - pos[i]) * (isMobile ? 0.15 : 0.1); // Transition plus rapide sur mobile
          col[i] += (targetColors[i] - col[i]) * 0.1;
        }
        for (let i = 0; i < PARTICLE_COUNT; i++) {
          siz[i] += (targetSizes[i] - siz[i]) * 0.1;
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particles.geometry.attributes.color.needsUpdate = true;
        particles.geometry.attributes.size.needsUpdate = true;

        // Rotations simplifi√©es
        if (currentTech === "red") {
          particles.rotation.z -= isMobile ? 0.05 : 0.1;
        } else if (currentTech === "purple") {
          particles.rotation.z += 0.1;
          particles.rotation.y += 0.03;
        } else if (currentTech === "shrine") {
          particles.rotation.set(0, 0, 0);
        } else {
          particles.rotation.y += 0.003;
        }

        // Render (avec ou sans composer)
        if (composer) {
          composer.render();
        } else {
          renderer.render(scene, camera);
        }
      }
      animate(0);

      // --- RESIZE HANDLER ---
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(
          Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2),
        );

        if (composer) {
          composer.setSize(window.innerWidth, window.innerHeight);
        }
      });

      // Gestion sortie de page
      window.addEventListener("pagehide", () => {
        if (cameraUtils) {
          cameraUtils.stop();
        }
      });
    </script>
  </body>
</html>
